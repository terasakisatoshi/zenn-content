---
title: "Qulacs ã‚’ä¾‹ã« Julia ã‹ã‚‰ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‘¼ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹è©±"
emoji: "ğŸƒ"
type: "tech"
topics:
  - "julia"
  - "python"
  - "qulacs"
  - "kyulacs"
  - "pycall"
published: true
published_at: "2022-02-01 02:50"
---

# æœ¬æ—¥ã¯

[Qulacs](http://docs.qulacs.org/ja/latest/) ã‚’ Julia ã‹ã‚‰ Pythonista ã«ã¨ã£ã¦è‡ªç„¶ãªå½¢ã§åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ãŸ [Kyulacs.jl](https://github.com/AtelierArith/Kyulacs.jl) ã‚’(ç§ãŒä½œã£ãŸã®ã§)ç´¹ä»‹ã—ã¾ã™. ç¾æ™‚ç‚¹ã§ã¯é‡è‰¯ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™.

Qulacs è‡ªä½“ã¯ [Qulacs](http://docs.qulacs.org/ja/latest/) ã«ã‚ã‚‹èª¬æ˜ã‚’å¼•ç”¨ã—ã¾ã™:

> Qulacsã¯ã€é«˜é€Ÿãªé‡å­å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ã‚ã‚Šã€å¤§ããªé‡å­å›è·¯ã‚„ãƒã‚¤ã‚ºãŒã‚ã£ãŸã‚Šã€ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ãªé‡å­å›è·¯ã«ã‚‚å¯¾å¿œã—ã¦ãŠã‚Šã¾ã™ã€‚ Qulacsã¯ã€C / C ++ã§å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€Pythonã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚‚ã‚ã‚‹ãŸã‚ã€é«˜é€Ÿå›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨é«˜ã„æ“ä½œæ€§ã®ä¸¡ç«‹ã—ã¾ã—ãŸã€‚


ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„å ´åˆã¯ [Quantum Native Dojo](https://dojo.qulacs.org/ja/latest/index.html) ã®[ï¼“ç« ](https://dojo.qulacs.org/ja/latest/notebooks/3.1_Qulacs_tutorial.html) ã‚’è¦‹ã‚‹ã¨è‰¯ã„ã§ã™. é‡å­ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’åˆã‚ã¦å­¦ã¶éš›ã‚‚ 2x2 ã®è¡Œåˆ—ãŒã§ãã‚‹ç¨‹åº¦ã®çŸ¥è­˜ã¨ã‚¯ãƒ­ãƒãƒƒã‚«ãƒ¼ç©ã‚’çŸ¥ã£ã¦ã„ã‚Œã° 1, 2 ç« ã‚’èª­ã‚ã°é›°å›²æ°—ã‚’æ´ã‚ã‚‹ã¨æ€ã„ã¾ã™ï¼

# Julia ã‹ã‚‰ã‚‚ä½¿ã„ãŸã„

Qulacs ã‚’ Julia ã‹ã‚‰ä½¿ã„ãŸã„å ´åˆä¸‹è¨˜ã®ã‚ˆã†ãªé¸æŠè‚¢ãŒã‚ã‚Šã¾ã™

- C/C++ API ã‚’ Clang.jl ã‚„ CxxWrap.jl ã‚’ä»‹ã—ã¦å‘¼ã³å‡ºã™
- Python API ã‚’ PyCall.jl ã‚’ä»‹ã—ã¦å‘¼ã³å‡ºã™
- ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã§ä½œã‚‹

ä»Šå›ã¯ Python API ã‚’ä½¿ã†æ–¹æ³•ã‚’æ¡ç”¨ã—ã¾ã—ãŸ. ã€Œã ã£ã¦Pythonä¾¿åˆ©ãªã‚“ã ã‚‚ãƒ¼ã‚“ã€ ã¨ã„ã†æœ¬éŸ³ã¨
ä¸­èº«ã¯ pybind11 ã‚’ä»‹ã—ã¦ C/C++ ã®ã‚³ãƒ¼ãƒ‰ãŒèµ°ã‚‹ã£ã½ã„ã®ã§åˆ©ä¾¿æ€§ã‚’é‡è¦–ã™ã‚‹æ–¹å‘ã«å‚¾ãã¾ã—ãŸ.

ãƒã‚¤ãƒã‚¤ï¼Œã©ã†ã› `using PyCall; qulacs=pyimport("qulacs")` ã™ã‚‹ã‚“ã§ã—ã‚‡ï¼ŸçŸ¥ã£ã¦ã‚‹çŸ¥ã£ã¦ã‚‹(ãƒ»Ï‰ãƒ»ï½€). ã¾ãã¾ãã‚‚ã†å°‘ã—ãŠä»˜ãåˆã„ãã ã•ã„ï¼

# å‘¼ã³å‡ºã—ã¾ã—ã‚‡ã†(æ„šç›´ãªæ–¹æ³•)

[Qulacs](https://github.com/qulacs/qulacs) ã® Readme ã«ã‚ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†.

```python
# readme_example.py
from qulacs import Observable, QuantumCircuit, QuantumState
from qulacs.gate import Y, CNOT, merge

state = QuantumState(3)
seed = 0  # set random seed
state.set_Haar_random_state(seed)

circuit = QuantumCircuit(3)
circuit.add_X_gate(0)
merged_gate = merge(CNOT(0, 1), Y(1))
circuit.add_gate(merged_gate)
circuit.add_RX_gate(1, 0.5)
circuit.update_quantum_state(state)

observable = Observable(3)
observable.add_operator(2.0, "X 2 Y 1 Z 0")
observable.add_operator(-3.0, "Z 2")
value = observable.get_expectation_value(state)
# 0.2835596510287872
print(value)
```

`PyCall.jl` ã‚’ä½¿ã†ã¨ `pyimport` é–¢æ•°ã«ã‚ˆã£ã¦ä¸‹è¨˜ã®ã‚ˆã†ã«åŒã˜ã“ã¨ãŒã§ãã¾ã™.

```julia
# readme_example.jl
using PyCall
qulacs = pyimport("qulacs")
QuantumState = qulacs.QuantumState
QuantumCircuit = qulacs.QuantumCircuit
Observable = qulacs.Observable

gate = pyimport("qulacs.gate")
Y = gate.Y
CNOT = gate.CNOT
merge = gate.merge

state = QuantumState(3)
seed = 0  # set random seed
state.set_Haar_random_state(seed)

circuit = QuantumCircuit(3)
circuit.add_X_gate(0)
merged_gate = merge(CNOT(0, 1), Y(1))
circuit.add_gate(merged_gate)
circuit.add_RX_gate(1, 0.5)
circuit.update_quantum_state(state)

observable = Observable(3)
observable.add_operator(2.0, "X 2 Y 1 Z 0")
observable.add_operator(-3.0, "Z 2")
value = observable.get_expectation_value(state)
# 0.2835596510287872
println(value)
```

PyCall.jl ã¯å‰å¤§ãªã®ã§ãŸã„ã¦ã„ã®Pythonãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‘¼ã³å‡ºã›ã¾ã™ï¼ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚‚ã¡ã‚ã‚“å‹•ä½œã—ã¾ã™ï¼ã§ã™ãŒï¼Œ`qulacs` ç›´ä¸‹ã«ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹ã‚¯ãƒ©ã‚¹ã‚„ `qulacs.gate` ä»¥ä¸‹ã«ã‚ã‚‹ã‚‚ã®ã‚’å‘¼ã³å‡ºã™ãŸã‚ã«
`qulacs.xxx` ã‚„ `qulacs.gate.xxx` ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã®ãŒã¡ã‚‡ã£ã¨ã ã‚‹ã„ã‚“ã§ã™ã‚ˆã­ï¼

å…ƒã€…ã®Pythonã®ã‚³ãƒ¼ãƒ‰ã¨åŒæ§˜ã«ã‚‚ã†å°‘ã—ç°¡å˜ã« `QuantumState` ã‚„ã‚²ãƒ¼ãƒˆã‚’å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã§ããªã„ã‚‚ã®ã‹ï¼Ÿ Kyulacs.jl ãŒãã‚Œã‚’è§£æ±ºã—ã¾ã™ï¼

# å‘¼ã³å‡ºã—ã¾ã—ã‚‡ã†(Kyulacs.jl ã«ã‚ˆã‚‹æ–¹æ³•)

Kyulacs.jl ã‚’ä½¿ã†ã¨ä¸‹è¨˜ã®ã‚ˆã†ã«ã§ãã¾ã™.

```julia
using Kyulacs: Observable, QuantumCircuit, QuantumState
using Kyulacs.Gate: CNOT, Y, merge

state = QuantumState(3)
seed = 0  # set random seed
state.set_Haar_random_state(seed)

circuit = QuantumCircuit(3)
circuit.add_X_gate(0)
merged_gate = merge(CNOT(0, 1), Y(1))
circuit.add_gate(merged_gate)
circuit.add_RX_gate(1, 0.5)
circuit.update_quantum_state(state)

observable = Observable(3)
observable.add_operator(2.0, "X 2 Y 1 Z 0")
observable.add_operator(-3.0, "Z 2")
value = observable.get_expectation_value(state)
# 0.2835596510287872
println(value)
```

Python ã® `from qulacs import ...` ã®éƒ¨åˆ†ã‚’ `using Kyulacs: ...` ã¨èª­ã¿æ›¿ãˆã‚‹ã“ã¨ã§ã‚ã¨ã¯ã»ã¼å…¨ã¦åŒã˜ã‚³ãƒ¼ãƒ‰ãŒä½¿ã„ã¾ã‚ã›ã¾ã™. 

### ç´°ã‹ã„è£œè¶³

å€¤ã‚’è¡¨ç¤ºã™ã‚‹ Pythonã® `print` ã¯ Julia ã§ã¯ `println` ã«ç›¸å½“ã—ã¾ã™. Julia ã® `print` ã¯ `println` ã®æ”¹è¡Œã‚’ã—ãªã„ç‰ˆã«ãªã‚Šã¾ã™.

```julia
julia> print(1); print(2); print(3)
123
julia> println(1); println(2); println(3)
1
2
3
```

å˜ã« Kyulacs.jl ã®ç´¹ä»‹ã ã¨ã“ã“ã§ãŠã—ã¾ã„ã§ã™ãŒï¼ŒKyulacs.jl ã§ä½¿ã£ã¦ã„ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ç´¹ä»‹ã—ã¦ã„ãã¾ã™ï¼

# pyimport("qulacs") ã¨ Kyulacs.jl ã®é•ã„

å˜ç´”ã« `pyimport` ã™ã‚‹ã ã‘ã®é•ã„ã‚’èª¬æ˜ã—ã¦ã„ãã¾ã™.

## Julia ã®å‹ã¨ã—ã¦è¦‹ãˆã¦ã„ã‚‹ã“ã¨

`using Kyulacs` ã‚’ã™ã‚‹ã¨ `qulacs` ã‚„ `QuantumState`, `QuantumCircuit`, `Observable` ãªã©ã‚’å³æ™‚ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™. ã“ã‚Œã‚‰ã®è­˜åˆ¥å­ã¯ Kyulacs module ã®å†…éƒ¨ã§ `export` ã‚’ã™ã‚‹ã¨å®£è¨€ã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™. `qulacs` ã¯ `pyimport("qulacs")` ã«ã‚ˆã£ã¦å¾—ã‚‰ã‚ŒãŸ `PyObject` ã‚’å‹ã«ã‚‚ã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™.

```julia
julia> using Kyulacs
julia> qulacs |> typeof
PyCall.PyObject
julia> qulacs.QuantumState |> typeof
PyCall.PyObject # ã›ã‚„ã‚ãª
julia> QuantumState |> typeof
DataType # ãŠã‚„ã?
```

`QuantumState` ã¯å˜ã« `PyObject` ã‚’å‹ã«ã‚‚ã¤ `qulacs.QuantumState` ã§ã¯ãªã Julia ã®æ§‹é€ ä½“ã¨ã—ã¦ Kyulacs ã‹ã‚‰ export ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™. 

ã›ã£ã‹ããªã®ã§ï¼’é‡å­çŠ¶æ…‹ã‚’è¡¨ã™ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†. [ä¾‹ãˆã°ã“ã“ã‚’èª­ã‚“ã§ã¿ã‚‹](https://dojo.qulacs.org/ja/latest/notebooks/3.1_Qulacs_tutorial.html#Qulacs%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9(1)%EF%BC%9A%E9%87%8F%E5%AD%90%E7%8A%B6%E6%85%8B)

```julia
julia> using Kyulacs
julia> state = QuantumState(2)
QuantumState(PyObject  *** Quantum State ***
 * Qubit Count : 2
 * Dimension   : 4
 * State vector :
(1,0)
(0,0)
(0,0)
(0,0)
)
julia> state.get_vector()
4-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
```

ã‚±ãƒƒãƒˆãƒ™ã‚¯ãƒˆãƒ«ã«ã‚ˆã‚‹è¡¨è¨˜ã§è¨€ãˆã° $|0\rangle^{\otimes 2}$ ã¨ã„ã†çŠ¶æ…‹ãŒå¾—ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™. ã¡ãªã¿ã« Julia ã ã¨ [Kronecker.jl](https://github.com/MichielStock/Kronecker.jl) ãŒæä¾›ã™ã‚‹ `âŠ—` é–¢æ•°ã‚’ä½¿ã£ã¦ç¢ºèªã§ãã¾ã™.

```julia
julia> using Kronecker
julia> Ïˆ = ComplexF64[1, 0]
2-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im
 
julia> Ïˆ âŠ— Ïˆ
4Ã—1 Kronecker.KroneckerProduct{ComplexF64, Matrix{ComplexF64}, Matrix{ComplexF64}}:
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
```

ã•ã¦, `state = QuantumState(2)` ã«ã‚ˆã£ã¦ state ã¨ã„ã† Julia ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½œã‚‰ã‚Œã¾ã—ãŸ. 

```julia
julia> state |> typeof
QuantumState
```
Julia ã® `QuantumState` æ§‹é€ ä½“ã¯ Python ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ ¼ç´ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã£ã¦ã„ã‚‹æ§‹é€ ä½“ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™. 

```julia
using PyCall
qulacs = pyimport("qulacs")
struct QuantumState
    pyobj::PyObject
    QuantumState(n) = new(qulacs.QuantumState(n))
end
```

å®Ÿéš›ï¼Œ`state.pyobj` ãŒå®Ÿè¡Œã§ãã¾ã™.

```julia
julia> using Kyulacs
julia> state = QuantumState(2);
julia> state.pyobj
PyObject  *** Quantum State ***
 * Qubit Count : 2
 * Dimension   : 4
 * State vector :
(1,0)
(0,0)
(0,0)
(0,0)

```

ã¤ã¾ã‚Š PyObject ã‚’å‹ã«ã™ã‚‹ Pythonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åŒ…ã¿è¾¼ã‚“ã§ã„ã‚‹ã ã‘ã§ã™ï¼

## ãƒ©ãƒƒãƒ—ã—ãŸPythonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ç´ã¥ã„ã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç›´ã«å‘¼ã³å‡ºã›ã‚‹

ä¸€æ–¹ã§ï¼Œ`get_vector` ã¨ã„ã† $2^2$ æ¬¡å…ƒã®çŠ¶æ…‹ãƒ™ã‚¯ãƒˆãƒ«ã‚’å–å¾—ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒãƒ‰ãƒƒãƒˆã‚’ä½¿ã£ãŸæ–¹æ³•ã§å‘¼ã³å‡ºã›ã¦ã„ãŸã“ã¨ã‚’æ€ã„å‡ºã—ã¾ã—ã‚‡ã†.

```
julia> state.get_vector() # Julia ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãªã®ã«ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã³å‡ºã›ã‚‹
4-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
```

çœŸé¢ç›®ã«è€ƒãˆã‚‹ã¨ä¸‹è¨˜ã®ã‚ˆã†ã« `pyobj` ã‚’çµŒç”±ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã¯ãšã§ã™.

```
julia> state.pyobj.get_vector() 
4-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 ```
 
 ãªãœã§ã—ã‚‡ã†ï¼Ÿ ğŸ§ ä¾‹ãˆã°Juliaã§æ¨™æº–ã«ä½¿ãˆã‚‹è¤‡ç´ æ•°å‹ã®å ´åˆã§è©¦ã™ã¨ä¸‹è¨˜ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ãã¾ã™:
 
```julia
julia> c = ComplexF64(1, 2)
1.0 + 2.0im

julia> c.re
1.0

julia> c.get_vector
ERROR: type Complex has no field get_vector
Stacktrace:
 [1] getproperty(x::ComplexF64, f::Symbol)
   @ Base ./Base.jl:42
 [2] top-level scope
   @ REPL[15]:1
```
 
 ### å®Ÿã¯ `Base.getproperty` ã‚’æ”¹é€ ã—ã¦ã„ã‚‹.
 
ä¸Šè¨˜ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚ˆãã¿ã‚‹ã¨ `getproperty` ã¨ã„ã†ã®ãŒå‡ºã¦ã„ã¾ã™ï¼å®Ÿã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ãŒè¨˜è¿°ã—ãŸ `state.get_object` ã¯ Julia å†…éƒ¨ã§ã¯
`getproperty(state, :get_object)` ã¨ã„ã†é–¢æ•°ã®å‘¼ã³å‡ºã—ã®å½¢ã«å¤‰æ›ã•ã‚Œã¾ã™. `:get_object` ã¯ Symbolã‚’å‹ã«ã‚‚ã¤ Julia ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™.
 
 [Base.jl: getproperty](https://github.com/JuliaLang/julia/blob/ac5cc99908d463582e66db3368b9b48fae1e2525/base/Base.jl#L42) ã‚’èª­ã‚€ã¨ `getfield` é–¢æ•°ã«å¸°ç€ã•ã‚ŒJuliaã®æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ï¼è¤‡ç´ æ•°ã®ä¾‹ã ã¨ `re` ã¨ã„ã†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹ã‹ã‚‰ `c.re` ãŒæ„å‘³ã‚’æŒã¡ `c.get_vector()` ã¨ã„ã†ã®ã¯ã‚¨ãƒ©ãƒ¼ã‚’å‡ºã™ã‚ã‘ã§ã™ï¼
 
 ä¸€èˆ¬è«–ã®èª¬æ˜ã¯ã“ã‚Œã¾ã§ã«ã—ã¦ QuantumState ã®å®Ÿè£…ã«æˆ»ã‚Šã¾ã™. å®Ÿã¯ Kyulacs.jl å†…éƒ¨ã§ã¯
 `QuantumState` ã«å¯¾ã™ã‚‹ `getproperty` é–¢æ•°ã‚’æ¬¡ã®ã‚ˆã†ã«å®Ÿè£…ã—ã¦ã„ã¾ã™:
 
```julia
function Base.getproperty(t::QuantumState, s::Symbol)
    if s âˆˆ fieldnames(QuantumState)
        return getfield(t, s)
    else
        return getproperty(getfield(t, :pyobj), s)
    end
end
```
 
 ã“ã‚Œã«ã‚ˆã£ã¦ `state.pyobj.get_vector` ã¨ã„ã†ã¾ã©ã‚ã£ã“ã—ã„æ›¸ãæ–¹ã‚’ã›ãšã« `state.get_vector` ã¨ã„ã†å½¢ã§ Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒª qulacs ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™. `:get_vector` ã¯ Julia æ§‹é€ ä½“ `QuantumState` ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã¯ãªã„ã®ã§
`getproperty(getfield(state, :pyobj), :get_vector)` ã¨ã„ã†ã®ãŒå®Ÿè¡Œã•ã‚Œã¾ã™.

## `state.<tab>` ã®è£œå®Œã¯ Python ã® `dir` ã®çµæœãŒå¾—ã‚‰ã‚Œã‚‹.

å˜ç´”ã« `pyobj` ã‚’åŒ…ã¿è¾¼ã‚€ã ã‘ã ã¨ `state.` ã®ã‚¿ãƒ–è£œå®Œã¯ `state.pyobj` ãŒå¾—ã‚‰ã‚Œã¦ã—ã¾ã„ã¾ã™. `get_vector` ã‚’è¦‹ã¤ã‘ã‚‹ã«ã¯ ``state.pyobj.<ã‚¿ãƒ–>` ã®ã‚ˆã†ã«ã‚„ã¯ã‚Š `pyobj` ã‚’çµŒç”±ã™ã‚‹å¿…è¦ãŒæœ‰ã‚Šã¾ã™. ã§ã™ãŒ Kyulacs ã®å®Ÿè£…ã ã¨ä¸‹è¨˜ã®ã‚ˆã†ã«ãªã‚Šã¾ã™.

```julia
julia> using Kyulacs; state = QuantumState(2)
julia> state. # ã“ã“ã§ã‚¿ãƒ–ã‚’é€£æ‰“
__class__                     __ne__                         get_marginal_probability
__delattr__                   __new__                        get_qubit_count
__dir__                       __reduce__                     get_squared_norm
__doc__                       __reduce_ex__                  get_vector
__eq__                        __repr__                       get_zero_probability
__format__                    __setattr__                    load
__ge__                        __sizeof__                     multiply_coef
__getattribute__              __str__                        multiply_elementwise_function
__gt__                        __subclasshook__               normalize
__hash__                      add_state                      sampling
__init__                      allocate_buffer                set_Haar_random_state
__init_subclass__             copy                           set_classical_value
__le__                        get_classical_value            set_computational_basis
__lt__                        get_device_name                set_zero_state
__module__                    get_entropy                    to_string
```

ã“ã‚Œã¯ `Base.propertynames` ã‚’æ¬¡ã®ã‚ˆã†ã«æ”¹é€ ã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™:

```julia
Base.propertynames(t::QuantumState)) = propertynames(getfield(t, :pyobj))
```

ã©ã†ã‚„ã‚‰ tab ã‚­ãƒ¼ã‚’æŠ¼ã—ãŸæ™‚ã®å€™è£œã¯ propertynames ã®æˆ»ã‚Šå€¤ãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã§ã™. ä¸Šè¨˜ã®æ”¹é€ ã«ã‚ˆã£ã¦ `pyobj` ä»¥ä¸‹ã®å€™è£œã‚’åˆ—æŒ™ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™.

# Python ãƒ¡ã‚½ãƒƒãƒ‰ã®å…¥åŠ›ã¯ Python ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã‚’æ¸¡ã™

æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¾ã™

```julia
using Kyulacs
state = QuantumState(2)
circuit = QuantumCircuit(2)
circuit.update_quantum_state(state)
```

`circuit.update_quantum_state(state)` ã¯æ³¨æ„æ·±ãè¦³å¯Ÿã™ã‚‹ã¨ `<Pythonã®ãƒ¡ã‚½ãƒƒãƒ‰>` ã«å¯¾ã—ã¦Julia ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ `state` ã‚’ã¤ã£ã“ã‚“ã§ã„ã¾ã™. `state` ã¯æˆ‘ã€…ãŒä½œã£ãŸ Julia æ§‹é€ ä½“ãªã®ã§ãã‚Œã‚’ãã®ã¾ã¾æ¸¡ã™ã¨ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã¦ã—ã¾ã„ã¾ã™. ãã“ã§ä¸‹è¨˜ã‚³ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦ Julia ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’PyObjectã™ã‚‹å¤‰æ›è¦å‰‡ã‚’ä¸ãˆã¦ã‚„ã‚Šã¾ã™ï¼ãã†ã™ã‚‹ã¨ PyCall ã®åŠ›ã§ Julia ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯åŒ…ã‚“ã§ã„ã‚‹ `pyobj` ã®æ–¹ã‚’ `update_quantum_state` ã®å¼•æ•°ã«æ¸¡ã—ã¦ã„ã‚‹ã‹ã®ã‚ˆã†ãªå‡¦ç†ã‚’è¡Œãˆã¾ã™.

```
using PyCall
PyObject(t::QuantumState) = t.pyobj
```

### ã“ã“ã¾ã§ã®ã¾ã¨ã‚

ä»Šã¾ã§ã®è©±ã‚’ã¾ã¨ã‚ã‚‹ã¨ä¸‹è¨˜ã«ç›¸å½“ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒ Kyulacs.jl ã«å…¥ã‚Šè¾¼ã‚“ã§ã„ã‚‹ã“ã¨ãŒæƒ³åƒã§ãã¾ã™.

```julia
struct QuantumState
    pyobj::PyObject
    QuantumState(args...) = new(qulacs.gate.QuantumState(args...))
end

PyObject(t::QuantumState) = t.pyobj

function Base.propertynames(t::QuantumState)
    propertynames(getfield(t, :pyobj))
end

function Base.getproperty(t::QuantumState, s::Symbol)
    if s âˆˆ fieldnames(QuantumState)
        return getfield(t, s)
    else
        return getproperty(getfield(t, :pyobj), s)
    end
end

export QuantumState
```

## ãƒã‚¯ãƒ­ã‚’ä½¿ã£ã¦è³„ã†

ã•ã¦ï¼Œå®Ÿéš›ã¯â†‘ã®ã‚ˆã†ãªã‚‚ã®ãŒ qulacs ã® `QuantumState` ã ã‘ã§ãªã `QuantumCircuit` ãªã©ã®ã•ã¾ã–ã¾ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚é©ç”¨ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™. å„ã€…ã®å‹ã®å®šç¾©ã«å¯¾ã—ã¦åŒã˜ã‚ˆã†ãªå®Ÿè£…ã‚’ã¤ã‚‰ã¤ã‚‰æ›¸ãã®ã¯è¾›ã„ã§ã™. ãã“ã§ Kyulacs.jl ã§ã¯ãƒã‚¯ãƒ­ã‚’ä½¿ã£ã¦ä¸Šè¨˜ã®å‡¦ç†ã‚’å„ã€…ã® qulacs ã®ã‚¯ãƒ©ã‚¹ã«å¯¾ã—ã¦è¡Œã£ã¦ã„ã¾ã™.

```julia
for class in [:QuantumState, :QuantumCircuit] # ã“ã“ã¯å®Ÿã¯ã„ã£ã±ã„ã‚ã‚‹
    @eval begin
        struct $class
            pyobj::PyObject
            $(class)(args...) = new(qulacs.$(class)(args...))
        end

        PyObject(t::$(class)) = t.pyobj

        function Base.propertynames(t::$(class))
            propertynames(getfield(t, :pyobj))
        end

        function Base.getproperty(t::$(class), s::Symbol)
            if s âˆˆ fieldnames($(class))
                return getfield(t, s)
            else
                return getproperty(getfield(t, :pyobj), s)
            end
        end

        export $(class)
    end
end
```

`@eval` ãƒã‚¯ãƒ­ã«ã‚ˆã£ã¦ãƒ«ãƒ¼ãƒ—å†…ã«ã‚ã‚‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å‘½ãŒå¹ãè¾¼ã¾ã‚Œ Pythonã®ã‚¯ãƒ©ã‚¹ã¨åŒåã® Julia ã®æ§‹é€ ä½“ãŒå®šç¾©ã•ã‚Œã¦ã„ãã¾ã™(ãã—ã¦ export ã‚‚ã•ã‚Œã‚‹).

`qulacs.gate` ä»¥ä¸‹ã«ã‚ã‚‹ã‚¯ãƒ©ã‚¹ã‚‚åŒæ§˜ãªæ‰‹æ³•ã§å¤‰æ›ã•ã‚Œã¾ã™. ä¾‹ãˆã° `CNOT` ã¯ `using Kyulacs.Gate` ã¨ã™ã‚‹ã“ã¨ã§ä½¿ãˆã¾ã™.

Julia ã®ãƒã‚¯ãƒ­ã™ã”ã„ã§ã—ã‚‡ï¼Ÿã“ã®æ©Ÿæ§‹ã®ãŠã‹ã’ã§ç§ã¯èª¿æŸ»ã‚‚å«ã‚ã¦ 1æ—¥ã§ Kyulacs.jl ã‚’ãƒªãƒªãƒ¼ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸï¼

# ã¾ã¨ã‚

Julia ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ Kyulacs.jl ã‚’ä½¿ã†ã“ã¨ã§ qulacs ã®æ©Ÿèƒ½ã‚’ Python ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦è‡ªç„¶ãªè¡¨è¨˜ã§åˆ©ç”¨ã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸ. Pythonã‚¯ãƒ©ã‚¹ã¨åŒåã®å‹ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ä»–ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æŠ½è±¡å‹ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã¨ã—ã¦æ´»ç”¨ã§ãã‚‹ä½™åœ°ã‚‚ä½œã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸï¼qulacs ã«é™ã‚‰ãšä»–ã® Python ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚‚å¿œç”¨ã§ãã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã™ã®ã§ãœã²ä½¿ã£ã¦ã¿ã¦ãã ã•ã„ï¼